In [1]: from zgulde.ds_imports import * # really just pandas and itertools, and the and_next fn
In [2]: df = pd.DataFrame({'install_id': ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C'], 'title_order': [1, 2, 3, 3, 1, 1, 1, 1, 2]})
In [3]: def is_list_sorted(l):
   ...:     for curr, nxt in and_next(l):
   ...:         if nxt is not None and curr > nxt:
   ...:             return False
   ...:     return True
   ...:
In [4]: df.groupby('install_id').title_order.apply(is_list_sorted)
Out[4]:
install_id
A     True
B    False
C     True
Name: title_order, dtype: bool
In [5]: from inspect import getsource
In [6]: getsource(and_next)
Out[6]: 'def and_next(xs: Iterable[A]) -> Iterator[Tuple[A, Optional[A]]]:\n    """\n    Return each of the items in the iterable xs, along with the next item.\n\n    When the iterable is exhausted, the last item is None.\n\n    Returns\n    -------\n\n    An iterable of tuples, where each tuple is the current item and the next\n    item.\n\n    >>> list(and_next([1, 2, 3]))\n    [(1, 2), (2, 3), (3, None)]\n    """\n    return it.zip_longest(xs, drop(xs, 1))\n'
In [7]: print(getsource(and_next))
def and_next(xs: Iterable[A]) -> Iterator[Tuple[A, Optional[A]]]:
    """
    Return each of the items in the iterable xs, along with the next item.
    When the iterable is exhausted, the last item is None.
    Returns
    -------
    An iterable of tuples, where each tuple is the current item and the next
    item.
    >>> list(and_next([1, 2, 3]))
    [(1, 2), (2, 3), (3, None)]
    """
    return it.zip_longest(xs, drop(xs, 1))